.merge-request
  = render "projects/merge_requests/show/mr_title"
  = render "projects/merge_requests/show/how_to_merge"
  = render "projects/merge_requests/show/mr_box"
  = render "projects/merge_requests/show/state_widget"
  = render "projects/merge_requests/show/commits"
  = render "projects/merge_requests/show/participants"

  - if @commits.present?
    %ul.nav.nav-pills.merge-request-tabs
      %li.notes-tab{data: {action: 'notes'}}
        = link_to project_merge_request_path(@project, @merge_request) do
          %i.fa.fa-comment
          Discussion
          %span.badge= @merge_request.mr_and_commit_notes.count
      %li.diffs-tab{data: {action: 'diffs'}}
        = link_to diffs_project_merge_request_path(@project, @merge_request) do
          %i.fa.fa-list-alt
          Changes
          %span.badge= @merge_request.diffs.size

  - content_for :note_actions do
    - if can?(current_user, :modify_merge_request, @merge_request)
      - if @merge_request.open?
        = link_to 'Close', project_merge_request_path(@project, @merge_request, merge_request: {state_event: :close }), method: :put, class: "btn btn-grouped btn-close close-mr-link js-note-target-close", title: "Close merge request"
      - if @merge_request.closed?
        = link_to 'Reopen', project_merge_request_path(@project, @merge_request, merge_request: {state_event: :reopen }), method: :put, class: "btn btn-grouped btn-reopen reopen-mr-link js-note-target-reopen", title: "Reopen merge request"

  .diffs.tab-content
    - if current_page?(action: 'diffs')
      = render "projects/merge_requests/show/diffs"
  .notes.tab-content.voting_notes#notes{ class: (controller.action_name == 'show') ? "" : "hide" }
    = render "projects/notes/notes_with_form"
  .mr-loading-status
    = spinner

:javascript
  var merge_request;

  merge_request = new MergeRequest({
    url_to_automerge_check: "#{automerge_check_project_merge_request_path(@project, @merge_request)}",
    check_enable: #{@merge_request.unchecked? ? "true" : "false"},
    url_to_ci_check: "#{ci_status_project_merge_request_path(@project, @merge_request)}",
    ci_enable: #{@project.ci_service ? "true" : "false"},
    current_status: "#{@merge_request.merge_status_name}",
    action: "#{controller.action_name}"
  });

:javascript   
   // Параметры
   var tensorCIParams = { // Параметры работы скрипта
         gitlabKey: 'S61nJcy6wSpYoai6PNmd',
         gitlabApiUrl: 'https://test-git.unix.tensor.ru/api/v3/',
         tcApiUrl: '/guestAuth/app/rest/',
         tcProtocol: 'https://'
      },
      cachedData = {
         currentProject: {
            id: -1
         }
      };
   
   /**
    * Проверяет что страница это MR и показывает информацию по сборкам
    */
   function showCIInfo() {
      if (isPageMergeRequest()) {
         getCurrentProjectInfo().done(function (data) {
            var projectName = $('h1.title > span').text().split('/')[1].trim();
            for (var i = 0; i < data.length; i++) {
               if (data[i].name === projectName) {
                  data = data[i];
                  break;
               }
            }
            if (data && data.description) {
               cachedData.currentProject = data;
               var metaInfo = JSON.parse(data.description.match(/\{.*\}/)[0]);
               if (metaInfo) {
                  showBuildsInfo(metaInfo);
                  // TODO: Показать коммиты, по которым сборка не прошла
               }
            }
         });
      }
   }
   
   /**
    * Проверяет является ли страница страницей с merge request'ом.
    * Возвращает true если является и false в ином случае.
    */
   function isPageMergeRequest() {
      return /https?:\/\/.*\/merge_requests\/\d+\/?/.test(document.location.href);
   }
   
   /**
    * Асинхронно получает мета-информацию по текущему проекту через GitLab API.
    * Возвращает jQuery deferred.
    */
   function getCurrentProjectInfo() {
      var projectName = $('h1.title > span').text().split('/')[1].trim(),
         URL = tensorCIParams.gitlabApiUrl + 'projects/search/' + projectName;
   
      return jQuery.ajax(URL, {
         'headers': {
            'Accept': 'application/json',
            'PRIVATE-TOKEN': tensorCIParams.gitlabKey
         }
      });
   }
   
   /**
    * Показывает информацию по сборкам по переданной структуре projectParams
    */
   function showBuildsInfo(projectParams) {
      getMergeRequestInfo().done(function (data) {
         var mergeRequestInfo = data[0],
            branchFrom = mergeRequestInfo.source_branch,
            branchTo = mergeRequestInfo.target_branch,
            buildsCount = projectParams.builds.length;
         if (projectParams.buildsPostfix) { // Если нужен постфикс, то делаем его (на данный момент актуально только для sbis3-ws и sbis3-stan)
            var postfix = branchFrom.split('/')[0].replace(/\./g, '');
            branchFrom = branchFrom.replace(/[^\/]+\//, '');
         }
   
         var $desc = $('.issue-box'),
            $ci = $desc.find('.ci');
         if (!$ci.length) {
            $ci = $('<div class="ci" style="padding: 15px 25px;"></div>');
            $desc.append($ci);
         }
         $ci.empty();
         $ci.append('<h4>Статус сборок по ветке</h4>');
   
         for (var i = 0; i < buildsCount; i++) {
            if (projectParams.buildsPostfix) {
               projectParams.builds[i] += postfix;
            }
            $ci.append(generateBuildRow(projectParams, projectParams.builds[i], branchFrom, branchTo)); // Вывести результаты на экран
         }
      });
   }
   
   /**
    * Получает информацию по Merge Request, соответствующему текущей странице
    * Возвращает jQuery deferred
    */
   function getMergeRequestInfo() {
      // Т. к. гитлаб не умеет возвращать мерж по id в проекте, а только по абсолютному id
      // воспользуемся небольшим хаком
      var mergeID = document.location.href.match(/\d+(?=$|\/$|\/diffs$)/)[0]; // ID мержа в проекте
      var titleText = $('.merge-request > .page-title').text(),
         projectID = cachedData.currentProject.id,
         URL = tensorCIParams.gitlabApiUrl + 'projects/' + projectID + '/merge_requests?per_page=1&page=' + mergeID,
         mergeRequestInfo = null;
      return jQuery.ajax(URL, {
         'headers': {
            'Accept': 'application/json',
            'PRIVATE-TOKEN': tensorCIParams.gitlabKey
         }
      });
   }
   
   /**
    * Генерирует и возвращает HTML верстку для очередной строки сборки
    */
   function generateBuildRow(projectParams, buildType, branchFrom, branchTo) {
      // TODO: (!!!) Узнать у CI-сервера какая ветка считается <default>
      var encodedBranchFrom = (branchFrom === 'master') ? encodeURIComponent('<default>') : encodeURIComponent(branchFrom),
         encodedBranchTo = (branchTo === 'master') ? encodeURIComponent('<default>') : encodeURIComponent(branchTo),
         html = '<p><a href="' + tensorCIParams.tcProtocol + projectParams.ciserver + '/viewType.html?buildTypeId=' + buildType + '&branch=' + encodedBranchFrom + '" class="' + buildType + '">' +
            '<span class="buildName"></span> (' + branchFrom + ')</a>: ' +
            '<img src="' + tensorCIParams.tcProtocol + projectParams.ciserver + tensorCIParams.tcApiUrl + 'builds/buildType:' + buildType + ',branch:' + encodedBranchFrom + '/statusIcon" /> &#8680 ' +
            '<a href="' + tensorCIParams.tcProtocol + projectParams.ciserver + '/viewType.html?buildTypeId=' + buildType + '&branch=' + encodedBranchTo + '" class="' + buildType + '">' +
            '<span class="buildName"></span> (' + branchTo + ')</a>: ';
      if (projectParams.buildsPostfix) { // Если есть постфикс, то ветка назначения чаще всего <default>
         html += '<img src="' + tensorCIParams.tcProtocol + projectParams.ciserver + tensorCIParams.tcApiUrl + 'builds/buildType:' + buildType + ',branch:' + encodeURIComponent('<default>') + '/statusIcon" /></p>';
      } else {
         html += '<img src="' + tensorCIParams.tcProtocol + projectParams.ciserver + tensorCIParams.tcApiUrl + 'builds/buildType:' + buildType + ',branch:' + encodedBranchTo + '/statusIcon" /></p>';
      }
   
      $.ajax({ // Асинхронно подгрузим человекочитаемое название
         url: tensorCIParams.tcProtocol + projectParams.ciserver + tensorCIParams.tcApiUrl + 'buildTypes/' + buildType,
         headers: {
            Accept: 'application/json'
         }
      }).done(function (res) {
         $('.' + buildType + ' .buildName').text(res.name);
      });
   
      return html;
   }
   showCIInfo();
