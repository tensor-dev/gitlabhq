.merge-request
  = render "projects/merge_requests/show/mr_title"
  = render "projects/merge_requests/show/how_to_merge"
  = render "projects/merge_requests/show/mr_box"
  = render "projects/merge_requests/show/state_widget"
  = render "projects/merge_requests/show/commits"
  = render "projects/merge_requests/show/participants"

  - if @commits.present?
    %ul.nav.nav-tabs
      %li.notes-tab{data: {action: 'notes'}}
        = link_to project_merge_request_path(@project, @merge_request) do
          %i.icon-comment
          Discussion
      %li.diffs-tab{data: {action: 'diffs'}}
        = link_to diffs_project_merge_request_path(@project, @merge_request) do
          %i.icon-list-alt
          Changes

  - content_for :note_actions do
    - if can?(current_user, :modify_merge_request, @merge_request)
      - unless @merge_request.closed? || @merge_request.merged?
        = link_to 'Close', project_merge_request_path(@project, @merge_request, merge_request: {state_event: :close }), method: :put, class: "btn btn-grouped btn-close close-mr-link", title: "Close merge request"
      - if @merge_request.closed?
        = link_to 'Reopen', project_merge_request_path(@project, @merge_request, merge_request: {state_event: :reopen }), method: :put, class: "btn btn-grouped btn-reopen reopen-mr-link", title: "Close merge request"

  .notes.tab-content.voting_notes#notes{ class: (controller.action_name == 'show') ? "" : "hide" }
    = render "projects/notes/notes_with_form"
  .diffs.tab-content
    - if current_page?(action: 'diffs')
      = render "projects/merge_requests/show/diffs"
  .status

:javascript
  var merge_request;

  merge_request = new MergeRequest({
    url_to_automerge_check: "#{automerge_check_project_merge_request_path(@project, @merge_request)}",
    check_enable: #{@merge_request.unchecked? ? "true" : "false"},
    url_to_ci_check: "#{ci_status_project_merge_request_path(@project, @merge_request)}",
    ci_enable: #{@project.gitlab_ci? ? "true" : "false"},
    current_status: "#{@merge_request.merge_status_name}",
    action: "#{controller.action_name}"
  });

:javascript   
   // Параметры
   var tensorCIParams = { // Параметры работы скрипта
         gitlabKey: 'S61nJcy6wSpYoai6PNmd',
         gitlabApiUrl: 'https://git.sbis.ru/api/v3/',
         tcApiUrl: '/guestAuth/app/rest/',
         tcProtocol: 'https://'
      },
      cachedData = {
         currentProject: {id: -1},
         currentMergeRequest: {id: -1}
      };
   
   /**
    * Проверяет что страница это MR и показывает информацию по сборкам
    */
   function showCIInfo() {
      if (isPageMergeRequest()) {
         var projectParams = getCurrentProjectInfo();
         if (projectParams) {
            showBuildsInfo(projectParams);
            // TODO: Показать коммиты, по которым сборка не прошла
         }
      }
   }
   
   /**
    * Проверяет является ли страница страницей с merge request'ом.
    * Возвращает true если является и false в ином случае.
    */
   function isPageMergeRequest() {
      return /https?:\/\/git\.sbis\.ru\/.*\/merge_requests\/\d+\/?/.test(document.location.href);
   }
   
   /**
    * Получает мета-информацию по текущему проекту, которая хранится в description.
    * Возвращает объект-описатель проекта или null, если получить инорфмацию не удалось.
    */
   function getCurrentProjectInfo() {
      var dataProjectID = $('body').attr('data-project-id'); // Здесь всегда хранится ID проекта
      if (cachedData.currentProject.id === dataProjectID) {
         return cachedData.currentProject;
      }
      var URL = tensorCIParams.gitlabApiUrl + 'projects/' + dataProjectID, // Ссылка для получения информации по проекту
         currentProject = null;
      if (!dataProjectID) {
         return null;
      }
      jQuery.ajax(URL, {
         'async': false,
         'headers': {
            'Accept': 'application/json',
            'PRIVATE-TOKEN': tensorCIParams.gitlabKey
         }
      }).done(function (data) {
         currentProject = data;
      });
   
      if (currentProject && currentProject.description) {
         cachedData.currentProject = currentProject;
         var metaInfo = currentProject.description.match(/\{.*\}/)[0];
         return JSON.parse(metaInfo);
      } else {
         return null;
      }
   }
   
   /**
    * Показывает информацию по сборкам по переданной структуре projectParams
    */
   function showBuildsInfo(projectParams) {
      var mergeRequestInfo = getMergeRequestInfo();
      if (!mergeRequestInfo) {
         return;
      }
      var branchFrom = mergeRequestInfo.source_branch,
         branchTo = mergeRequestInfo.target_branch,
         buildsCount = projectParams.builds.length;
   
      if (projectParams.buildsPostfix) { // Если нужен постфикс, то делаем его (на данный момент актуально только для sbis3-ws и sbis3-stan)
         var postfix = branchFrom.split('/')[0].replace(/\./g, '');
         branchFrom = branchFrom.replace(/[^\/]+\//, '');
      }
   
      var $desc = $('.issue-box'),
          $ci = $desc.find('.ci');
      if (!$ci.length) {
         $ci = $('<div class="ci" style="padding: 15px 25px;"></div>');
         $desc.append($ci);
      }
      $ci.empty();
      $ci.append('<h4>Статус сборок по ветке</h4>');
   
      for (var i = 0; i < buildsCount; i++) {
         if (projectParams.buildsPostfix) {
            projectParams.builds[i] += postfix;
         }
         $ci.append(generateBuildRow(projectParams, projectParams.builds[i], branchFrom, branchTo)); // Вывести результаты на экран
      }
   }
   
   /**
    * Возвращает информацию по MR, соответствующему текущей странице
    * Если получить информацию не удалось возвращает null
    */
   function getMergeRequestInfo() {
      // Т. к. гитлаб не умеет возвращать мерж по id в проекте, а только по абсолютному id
      // воспользуемся небольшим хаком
      var mergeID = document.location.href.match(/\d+(?=$|\/$|\/diffs$)/)[0]; // ID мержа в проекте
      if (cachedData.currentMergeRequest.id === mergeID) {
         return cachedData.currentMergeRequest;
      }
      var titleText = $('.merge-request > .page-title').text(),
         projectID = $('body').attr('data-project-id'),
         URL = tensorCIParams.gitlabApiUrl + 'projects/' + projectID + '/merge_requests?per_page=1&page=' + mergeID,
         mergeRequestInfo = null;
      jQuery.ajax(URL, {
         'async': false,
         'headers': {
            'Accept': 'application/json',
            'PRIVATE-TOKEN': tensorCIParams.gitlabKey
         }
      }).done(function (data) {
         mergeRequestInfo = data[0];
      });
      cachedData.currentMergeRequest = mergeRequestInfo;
      return mergeRequestInfo;
   }
   
   /**
    * Генерирует и возвращает HTML верстку для очередной строки сборки
    */
   function generateBuildRow(projectParams, buildType, branchFrom, branchTo) {
      // TODO: (!!!) Узнать у CI-сервера какая ветка считается <default>
      var encodedBranchFrom = (branchFrom === 'master') ? encodeURIComponent('<default>') : encodeURIComponent(branchFrom),
         encodedBranchTo = (branchTo === 'master') ? encodeURIComponent('<default>') : encodeURIComponent(branchTo),
         html = '<p><a href="' + tensorCIParams.tcProtocol + projectParams.ciserver + '/viewType.html?buildTypeId=' + buildType + '&branch=' + encodedBranchFrom + '" class="' + buildType + '">' +
            '<span class="buildName"></span> (' + branchFrom + ')</a>: ' +
            '<img src="' + tensorCIParams.tcProtocol + projectParams.ciserver + tensorCIParams.tcApiUrl + 'builds/buildType:' + buildType + ',branch:' + encodedBranchFrom + '/statusIcon" /> &#8680 ' +
            '<a href="' + tensorCIParams.tcProtocol + projectParams.ciserver + '/viewType.html?buildTypeId=' + buildType + '&branch=' + encodedBranchTo + '" class="' + buildType + '">' +
            '<span class="buildName"></span> (' + branchTo + ')</a>: ';
      if (projectParams.buildsPostfix) { // Если есть постфикс, то ветка назначения чаще всего <default>
         html += '<img src="' + tensorCIParams.tcProtocol + projectParams.ciserver + tensorCIParams.tcApiUrl + 'builds/buildType:' + buildType + ',branch:' + encodeURIComponent('<default>') + '/statusIcon" /></p>';
      } else {
         html += '<img src="' + tensorCIParams.tcProtocol + projectParams.ciserver + tensorCIParams.tcApiUrl + 'builds/buildType:' + buildType + ',branch:' + encodedBranchTo + '/statusIcon" /></p>';
      }
   
      $.ajax({ // Асинхронно подгрузим человекочитаемое название
         url: tensorCIParams.tcProtocol + projectParams.ciserver + tensorCIParams.tcApiUrl + 'buildTypes/' + buildType,
         headers: {
            Accept: 'application/json'
         }
      }).done(function (res) {
         $('.' + buildType + ' .buildName').text(res.name);
      });
   
      return html;
   }
   
   showCIInfo();
